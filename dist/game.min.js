function Tile(ctx, n, x, y, s, r) {
    'use strict';
    this.ctx = ctx;
    this.n = n;
    this.x = x;
    this.y = y;
    this.s = s;
    this.r = r;
    this.c = '#193441';
    var fs = Math.round(s / 2);
    this.font = '700 ' + fs + 'px fantasy';
    this.moves = {
        right: ['x', 1],
        left: ['x', -1],
        up: ['y', -1],
        down:['y', 1]
    };
}

Tile.prototype.draw = function() {
    var it = this;
    it.ctx.roundRect(it.x, it.y, it.s, it.s, it.r);
    it.ctx.fillStyle = it.c;
    it.ctx.fill();

    it.ctx.font = it.font;
    it.ctx.textAlign = 'center';
    it.ctx.textBaseline = 'middle';
    it.ctx.strokeStyle = '#91AA9D';
    it.ctx.lineWidth = 1;
    it.ctx.strokeText(it.n, it.x + it.s / 2, it.y + it.s / 2);
};

Tile.prototype.move = function(dir) {
    var m = this.moves[dir];
    this[m[0]] += m[1] * (this.s + this.r);
};

function Game() {
    this.numbers = getNumbers();
    var tiles = {};
    this.numbers.forEach(function(n, i) {
        tiles[n] = getCoords(i);
    });

    isCompleted();

    this.checkLine = function(n) {
        return (tiles[n].col === tiles['0'].col) || (tiles[n].row === tiles['0'].row);
    };

    this.checkState = function(n) {
        var hole = tiles['0'];
        var arr = [];
        var keys = Object.keys(tiles);
        var move, steps;
        if (tiles[n].col === hole.col) {
            steps = hole.row - tiles[n].row;
            move = (steps > 0) ? 'down' : 'up';
            keys.forEach(function(key) {
                if (+key && (tiles[key].col === hole.col)) {
                    if (move === 'down') {
                        if (tiles[key].row >= tiles[n].row && tiles[key].row < hole.row) {
                            tiles[key].row += 1;
                            arr.push(key);
                        }
                    } else {
                        if (tiles[key].row <= tiles[n].row && tiles[key].row > hole.row) {
                            tiles[key].row -= 1;
                            arr.push(key);
                        }
                    }
                }
            });
            hole.row -= steps;
        } else if (tiles[n].row === hole.row) {
            steps = hole.col - tiles[n].col;
            move = (steps > 0) ? 'right' : 'left';
            keys.forEach(function(key) {
                if (+key && (tiles[key].row === hole.row)) {
                    if (move === 'right') {
                        if (tiles[key].col >= tiles[n].col && tiles[key].col < hole.col) {
                            tiles[key].col += 1;
                            arr.push(key);
                        }
                    } else {
                        if (tiles[key].col <= tiles[n].col && tiles[key].col > hole.col) {
                            tiles[key].col -= 1;
                            arr.push(key);
                        }
                    }
                }
            });
            hole.col -= steps;

        }
        var completed = isCompleted();
        return {
            move: move,
            arr: arr,
            completed: completed
        };
    };

    function isCompleted() {
        var keys = Object.keys(tiles);
        return keys.every(function(key) {
            if ( key === '0' ) {
                return true;
            }
            var coords = getCoords((+key - 1));
            return (coords.col === tiles[key].col) && (coords.row === tiles[key].row);
        });
    }

    function getCoords(i) {
        return {
            col: i%4,
            row: Math.floor(i/4)
        };
    }

    function getNumbers(pool, nums, temp) {
        pool = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
        nums = pool.sort(rndSort).concat(0);

        var pool1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 13, 0];
        console.log(isSolvable(pool1));

        nums = pool1;

        if (!isSolvable(nums)) {
            temp = nums[0];
            nums[0] = nums[1];
            nums[1] = temp;
        }

        return nums;

        function rndSort() {
            return Math.random() - 0.5;
        }

        function isSolvable(a, i, j, len, dis, t) {
            for (dis = 0, i = 1, len = a.length - 1; i < len; i++) {
                for (j = i - 1; j >= 0; j--) {
                    if (a[j] > a[i]) {
                        dis++;
                    }
                }
            }
            t = dis % 2;
            return !t;
        }
    }
}

(function() {
    'use strict';

    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) {
            r = w / 2;
        }
        if (h < 2 * r) {
            r = h / 2;
        }
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };

    var canvas = document.querySelector('canvas');
    var ctx = canvas.getContext('2d');
    var p = new Props();
    var game = new Game();
    var tiles = createTiles(game.numbers, p);
    var timer = new Timer();

    canvas.width = canvas.height = p.size;
    canvas.style.marginLeft = p.marginLeft + 'px';
    canvas.style.marginTop = p.marginTop + 'px';
    setEventListeners();
    drawStage();

    function createTiles(nums, p) {
        var arr = [],
            i = 0,
            x, y;

        nums.forEach(function (n, i) {
            if ( n ) {
                x = p.gap + (i % 4) * (p.tile + p.gap);
                y = p.gap + (Math.floor(i / 4)) * (p.tile + p.gap);
                arr[i] = new Tile(ctx, n.toString(), x, y, p.tile, p.gap);
            }
        });
        return arr;
    }

    function drawStage() {
        ctx.clearRect(0, 0, p.size, p.size);
        ctx.strokeStyle = '#193441';
        ctx.lineWidth = 6;
        ctx.strokeRect(0, 0, p.size, p.size);
        tiles.forEach(function(tile) {
            tile.draw();
        });
    }

    function setEventListeners() {
        canvas.addEventListener('mouseleave', onMouseLeave, false);
        canvas.addEventListener('click', onMouseClick, false);
        canvas.addEventListener('mousemove', onMouseMove, false);
    }

    function removeEventListeners() {
        canvas.removeEventListener('mouseleave', onMouseLeave);
        canvas.removeEventListener('click', onMouseClick);
        canvas.removeEventListener('mousemove', onMouseMove);
    }


    function onMouseLeave() {
        for (var i = 0; i < 15; i++) {
            tiles[i].c = '#193441';
        }
        canvas.style.cursor = 'auto';
        drawStage();
    }


    function onMouseClick(e) {
        var mouse = getMousePosition(canvas, e);
        for (var i = 0; i < 15; i++) {
            if ( pointInRect(mouse, tiles[i]) ) {
                var data = game.checkState(tiles[i].n);
                if ( data.move ) {
                    updateTiles(data);
                    drawStage();
                    if ( data.completed ) {
                        removeEventListeners();
                        for (var j = 0; j < 15; j++) {
                            tiles[j].c = '#FCFFF5';
                        }
                        canvas.style.cursor = 'auto';
                        timer.show();
                    }
                    drawStage();
                }
                break;
            }
        }
    }

    function updateTiles(d) {
        tiles.forEach(function(tile) {
            if ( d.arr.indexOf(tile.n) !== -1 ) {
                tile.move(d.move);
            }
        });
    }

    function setMovedStyles(i) {
        drawStage();
    }

    function onMouseMove(e) {
        var mouse = getMousePosition(canvas, e);
        var cursor = 'auto';
        for (var i = 0; i < 15; i++) {
            if ( pointInRect(mouse, tiles[i]) && game.checkLine(tiles[i].n)) {
                tiles[i].c = '#3E606F';
                cursor = 'pointer';
            }else  {
                tiles[i].c = '#193441';
            }
        }
        canvas.style.cursor = cursor;
        drawStage();
    }

    function getMousePosition(c, e) {
        var bcr = c.getBoundingClientRect();
        return {
            x: e.pageX - bcr.left,
            y: e.pageY - bcr.top
        };
    }

    function pointInRect (point, rect) {
        return inRange(point.x, rect.x, rect.x + rect.s) && inRange(point.y, rect.y, rect.y + rect.s);
    }

    function inRange (value, min, max) {
        return value >= Math.min(min, max) && value <= Math.max(min, max);
    }
})();
// FCFFF5 D1DBBD 91AA9D 3E606F 193441

function Props() {
    var full = (Math.min(window.innerWidth, window.innerHeight) * 0.85);
    full = (full <= 450) ? full : 450;
    this.gap = Math.round(full/45);
    this.size = this.gap * 45;
    this.marginLeft = Math.round((window.innerWidth - this.size)/2);
    this.marginTop = Math.round((window.innerHeight - this.size)/2);
    this.tile = this.gap * 10;
}

function Timer() {
    var startTime = Date.now();

    this.show = function() {
        var now = Date.now();
        var sec = Math.round((now - startTime)/1000);
        console.log(sec);
    };

}

//# sourceMappingURL=game.min.js.map
